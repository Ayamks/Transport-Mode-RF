# -*- coding: utf-8 -*-
"""004_Preprocessing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12FyfN7Qa9QGbi335TsBE2waXZPzMufly
"""

# Mount The Google Drive
from google.colab import drive
drive.mount('/content/gdrive')

# Import Libraries
import os
import numpy as np
import pandas as pd
import time
import datetime
import pickle
import random
import math
#from geopy.distance import vincenty
from geopy.distance import GeodesicDistance, distance, geodesic
pd.options.mode.chained_assignment = None
print("Libraries Are Imported")

# Define Path of Data
path = '/content/gdrive/MyDrive/Colab Notebooks/'
os.chdir(path)

# Read The Labeled Data
Data = '003_Labeled_GeoLife.pickle'
infile = open(Data,'rb')
df = pickle.load(infile)
infile.close()

for user, dF in df.items():
    print(f"First 5 lines of DataFrame for user {user}:")
    print(dF.head())
    print("\n")

# Initialize an empty list to collect DataFrames
dfs = []

# Iterate over items in `df` dictionary
for key, value in df.items():
    # Convert each value (which is a dictionary) to a DataFrame
    temp_df = pd.DataFrame(value)
    # Append the DataFrame to the list
    dfs.append(temp_df)

# Concatenate all DataFrames into a single DataFrame
DF = pd.concat(dfs, axis=0, ignore_index=True)

# Ensure the concatenated DataFrame has the 'Mode' column
if 'Mode' not in DF.columns:
    raise KeyError("The 'Mode' column is not present in the DataFrame.")

# Select Just These Modes for the Project
Pr_Mode = ['bus', 'car', 'walk', 'bike', 'taxi', 'train', 'subway']

DF = DF[DF['Mode'].isin(Pr_Mode)]

DF.head()

DF.shape

df = DF.copy()

df.reset_index(drop = True, inplace = True)

# Drop rows with Equal Times

# Identify duplicate rows based on 'Trip' and 'TS' columns
duplicates = df.duplicated(subset=['Trip', 'TS'], keep='first')

# Drop the duplicates
df = df[~duplicates]

print(df)

# Calculate Distance between GPS points / Has to be changed taking too much time
Dist = []
for i in range(len(df)-1):
  A = (df['Latitude'].iloc[i], df['Longitude'].iloc[i])
  B = (df['Latitude'].iloc[i+1], df['Longitude'].iloc[i+1])
  Dist.append(distance(A, B).meters)

# Insert Distance of First point from itself equal to zero
Dist.insert(0, 0)

df['Distance'] = Dist
print(df)

# Distance at Start of each trip is equal to zero
# Identify the rows where the trip changes
trip_change_indices = df.index[df['Trip'].shift() != df['Trip']]

# Reset the Distance at the start of each trip to zero
df.loc[trip_change_indices, 'Distance'] = 0

# Ensure the first row's Distance is set to zero if needed
if len(df) > 0:
    df.loc[df.index[0], 'Distance'] = 0

# Calculate Delta Time using vectorized operation
df['DT'] = df['TS'].diff()

# The first row of DT will be NaN because there's no previous TS value.
# You may want to handle this if necessary:
df.loc[0, 'DT'] = 0  # Set the first value of DT to 0 if needed

# If you specifically need DT as a list, you can convert it after calculation:
DT = df['DT'].tolist()

DT.insert(0, 0)

# Calculate Delta Time using vectorized operation
df['DT'] = df['TS'].diff()

# The first row of DT will be NaN because there's no previous TS value.
# Set the first value of DT to 0 if needed
df.loc[df.index[0], 'DT'] = 0

# Create a mask where 'Trip' changes from one row to the next
mask = df['Trip'] != df['Trip'].shift(-1)

# Use loc to set values in 'DT' column based on the mask
df.loc[mask, 'DT'] = 0

# Ensure the last row's 'DT' value is set correctly if needed
df.loc[df.index[-1], 'DT'] = 0

# Compute the Speed
df['Speed'] = df['Distance'] / df['DT']

df['Speed'].iloc[0] = 0.0

# Identify where 'Trip' changes
trip_change_indices = df.index[df['Trip'].shift(-1) != df['Trip']]

# Set 'Speed' to 0 where 'Trip' changes
df.loc[trip_change_indices, 'Speed'] = 0

D_Speed = []
# Calculate the difference in 'Speed' using vectorized operations
df['D_Speed'] = df['Speed'].diff()

# For the first row of each trip, set D_Speed to NaN or 0 as needed
first_trip_indices = df.index[df['Trip'].shift(1) != df['Trip']]
df.loc[first_trip_indices, 'D_Speed'] = 0  # or df.loc[first_trip_indices, 'D_Speed'] = pd.NA for NaN

# Drop the last row of each trip since it doesn't have a subsequent row to calculate D_Speed
df = df.dropna(subset=['D_Speed'])

D_Speed.insert(0, 0)

# Calculate D_Speed
df['D_Speed'] = df['Speed'].diff()
df['D_Speed'].fillna(0, inplace=True)

# Compute Acceleation or Decelaraion
df['Acc'] = df['D_Speed'] / df['DT']

df['Acc'].iloc[0] = 0.0

# Find rows where Trip changes
mask = df['Trip'] != df['Trip'].shift(-1)

# Set Acc to 0 for rows where Trip changes
df.loc[mask, 'Acc'] = 0

# Calculate Delta Acceleration (D_Acc)
df['D_Acc'] = df['Acc'].diff()

# Replace NaN with 0 for the first row
df['D_Acc'].iloc[0] = 0

# Compute Jerk
df['Jerk'] = df['D_Acc'] / df['DT']

df['Jerk'].iloc[0] = 0.0

# Create a boolean mask to identify where Trip changes
mask = df['Trip'] != df['Trip'].shift(-1)

# Set Jerk to 0 where Trip changes
df.loc[mask, 'Jerk'] = 0

# Change Latitude, Longitude, and Altitude from String to Number
df['Latitude'] = pd.to_numeric(df['Latitude'])
df['Longitude'] = pd.to_numeric(df['Longitude'])
df['Altitude'] = pd.to_numeric(df['Altitude'])

# Calculate Bearing feature between two GPS points
bearing = []

for i in range(len(df)-1):
  y = math.sin(math.radians(df['Longitude'].iloc[i+1]) - math.radians(df['Longitude'].iloc[i])) * math.radians(math.cos(df['Latitude'].iloc[i+1]))
  x = math.radians(math.cos(df['Latitude'].iloc[i])) * math.radians(math.sin(df['Latitude'].iloc[i+1])) - \
                math.radians(math.sin(df['Latitude'].iloc[i])) * math.radians(math.cos(df['Latitude'].iloc[i+1])) \
                * math.radians(math.cos(df['Longitude'].iloc[i+1]) - math.radians(df['Longitude'].iloc[i]))
  b = (math.atan2(y, x) * 180. / math.pi + 360) % 360
  bearing.append(b)

bearing.insert(0,0)
df['Bearing'] = bearing

for i in range(len(df)-1):
  if df['Trip'].iloc[i] != df['Trip'].iloc[i+1]:
    df['Bearing'].iloc[i+1] = 0

# Extract Cumulative Distance Feature for each single Trip
ggg = df.groupby('Trip')
Cum = []

for i, j in ggg:
  Cum.append((np.cumsum(j['Distance'])))

temp = []
for i in range(len(Cum)):
  temp.extend(Cum[i])

df['Cum_Distance'] = temp

# Drop Extra Columns
df.drop(['D_Speed','D_Acc'],axis=1,inplace=True)

df.replace({"taxi": "car", "subway": "train"},inplace= True)

# Apply Exponential Moving Average to Noises for Speed Feature
All_Modes = ["bike", "bus", "car", "train", "walk"]
feature = "Speed"
alpha = 0.1

# Calculate the EMA for the Speed column once
df['EMA_Speed'] = df[feature].ewm(alpha=alpha, adjust=False).mean()

# Function to apply the filter for a specific mode
def apply_ema_filter(df, mode, feature):
    mean = df[df['Mode'] == mode][feature].mean()
    std = df[df['Mode'] == mode][feature].std()
    down_bound = mean - (3 * std)
    up_bound = mean + (3 * std)
    mask = (df['Mode'] == mode) & ((df[feature] > up_bound) | (df[feature] < down_bound))
    df.loc[mask, feature] = df.loc[mask, 'EMA_Speed']

# Apply the filter for each mode
for mode in All_Modes:
    print(mode)
    apply_ema_filter(df, mode, feature)

# Drop the temporary EMA column
df.drop(columns='EMA_Speed', inplace=True)

print(df)

# Apply Exponential Moving Average to Noises for Acceleration Feature
All_Modes = ["bike", "bus", "car", "train", "walk"]
feature = "Acc"
alpha = 0.1

# Calculate the EMA for the Acc column once
df['EMA_Acc'] = df[feature].ewm(alpha=alpha, adjust=False).mean()

# Function to apply the filter for a specific mode
def apply_ema_filter(df, mode, feature):
    mean = df[df['Mode'] == mode][feature].mean()
    std = df[df['Mode'] == mode][feature].std()
    down_bound = mean - (3 * std)
    up_bound = mean + (3 * std)
    mask = (df['Mode'] == mode) & ((df[feature] > up_bound) | (df[feature] < down_bound))
    df.loc[mask, feature] = df.loc[mask, 'EMA_Acc']

# Apply the filter for each mode
for mode in All_Modes:
    print(mode)
    apply_ema_filter(df, mode, feature)

# Drop the temporary EMA column
df.drop(columns='EMA_Acc', inplace=True)

print(df)

# Apply Exponential Moving Average to Noises for Jerk Feature
All_Modes = ["bike", "bus", "car", "train", "walk"]
feature = "Jerk"
alpha = 0.1

# Calculate the EMA for the Jerk column once
df['EMA_Jerk'] = df[feature].ewm(alpha=alpha, adjust=False).mean()

# Function to apply the filter for a specific mode
def apply_ema_filter(df, mode, feature):
    mean = df[df['Mode'] == mode][feature].mean()
    std = df[df['Mode'] == mode][feature].std()
    down_bound = mean - (3 * std)
    up_bound = mean + (3 * std)
    mask = (df['Mode'] == mode) & ((df[feature] > up_bound) | (df[feature] < down_bound))
    df.loc[mask, feature] = df.loc[mask, 'EMA_Jerk']

# Apply the filter for each mode
for mode in All_Modes:
    print(mode)
    apply_ema_filter(df, mode, feature)

# Drop the temporary EMA column
df.drop(columns='EMA_Jerk', inplace=True)

print(df)

# Drop Trips with Length Smaller than 60 rows of GPS Data

min_rows = 60
DF = pd.DataFrame()

# Collect DataFrames for trips with more than `min_rows` rows
dfs = [j for i, j in df.groupby('Trip') if len(j) > min_rows]

# Concatenate the collected DataFrames
DF = pd.concat(dfs, ignore_index=True)

print(DF)
print(DF.shape)

DF.reset_index(drop = True, inplace = True)

with open("004_Preprocessed_Data.pickle", 'wb') as f:
    pickle.dump(DF, f)

# Filter the DataFrame for the specific trip number
specific_trip_id = 101_156.0_1
df_specific_trip = df[df['Trip'] == specific_trip_id]

# Print the filtered DataFrame
print(df_specific_trip)