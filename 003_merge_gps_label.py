# -*- coding: utf-8 -*-
"""003_Merge_GPS_Label.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rXjtNVFIFhZpW8qihRinY9QMvhYY6OHR
"""

# Mount Google Drive
from google.colab import drive
drive.mount('/content/gdrive')

# Import Libraries
import os
import pandas as pd
import time
import datetime
import pickle
pd.options.mode.chained_assignment = None
print("Libraries Are Imported")

# Define Path of GPS and Label Pickle Data
path = '/content/gdrive/MyDrive/Colab Notebooks/'
os.chdir(path)

# Read All GPS Data
GPS = '001_All_GeoLife_GPS.pickle'
infile = open(GPS,'rb')
GPS_1 = pickle.load(infile)
infile.close()

# Merge Date and Time Column of GPS Data
GPS_1['Date'] = GPS_1['Date'] + " " + GPS_1['Time']

# Drop Time Column of GPS Data
GPS_1.drop('Time', inplace = True, axis =1)

# Read All Label Data
Label = '002_All_GeoLife_Label.pickle'
infile = open(Label,'rb')
Label_1 = pickle.load(infile)
infile.close()

# All Modes of Transport in the All Geolife Dataset
Mode_List = Label_1['Mode'].unique().tolist()
Mode_List

Date = []
Mode = []
User = []
TS = []

for i in range(len(Label_1)):
  Date.append(Label_1['Start'].iloc[i])
  Date.append(Label_1['End'].iloc[i])
  Mode.append(Label_1['Mode'].iloc[i])
  Mode.append(Label_1['Mode'].iloc[i])
  User.append(Label_1['User'].iloc[i])
  User.append(Label_1['User'].iloc[i])
  TS.append(Label_1['Start_TS'].iloc[i])
  TS.append(Label_1['End_TS'].iloc[i])

Data = {'Date':Date, 'User':User, 'Mode':Mode, 'TS':TS}

Label = pd.DataFrame(Data)

# Labeling GPS Data Points
All_Df = {}
for i in GPS_1['User'].unique():
  Temp_gps = GPS_1[GPS_1['User'] == i]
  temp_lab = Label[Label['User'] == i]
  frames = [Temp_gps, temp_lab]
  Temp = pd.concat(frames)
  frames = []
  Temp = Temp.sort_values('TS')


  ind = []
  for j in range(len(Temp)):
    if Temp['Mode'].iloc[j] in Mode_List:
      ind.append(j)

  l = 0
  k = 0

  while l < len(ind):
    Temp['Mode'][ind[l]:ind[l+1]] = temp_lab['Mode'].iloc[k]
    l += 2
    k += 2

  All_Df[f'{i}'] = Temp

for i in All_Df.keys():
  All_Df[f'{i}'].dropna(inplace = True)

All_Df['53']

# Print trips, and th corresponding dates and modes for a specific user
# Set pandas to display all rows
pd.set_option('display.max_rows', None)

user_to_print = '53'

if user_to_print in All_Df:
     user_data = All_Df[user_to_print]
     print(f"Trip and Mode data for User {user_to_print}:")
     print(user_data[['Trip', 'Mode', 'Date']])
else:
    print(f"User {user_to_print} not found in the dictionary.")

# Look for multiple modes in a single trip

results = []


for user, df in All_Df.items():
    grouped = df.groupby('Trip')

    for trip, group in grouped:
        if len(group['Mode'].unique()) > 1:
            results.append((user, trip, group['Mode'].unique().tolist()))


for user, trip, modes in results:
    print(f"User {user} has trip {trip} with multiple modes: {modes}")

# Function to segment trips based on mode changes
#def segment_trips(df):
    #if df.empty:
        #return df

    # Identify where the mode changes
    #mode_change = df['Mode'].shift(1) != df['Mode']

    # Increment trip ID by 1 where there's a mode change
    #df['Trip'] = df['Trip'] + mode_change.cumsum()

    #return df

# Iterate over each user and apply the segmentation
#for user in All_Df.keys():
    #df = All_Df[user]
    #segmented_df = segment_trips(df)
    #All_Df[user] = segmented_df

# Function to segment trips based on mode changes
def segment_trips(df):
    if df.empty:
        return df

    # Identify where the mode changes
    mode_change = df['Mode'].shift(1) != df['Mode']

    # Increment trip ID by 1 where there's a mode change
    df['Trip'] = df['Trip'].astype(str) + "_" + mode_change.cumsum().astype(str)

    return df

# Add unique identifier for each user to the trip number
for user in All_Df.keys():
    df = All_Df[user]
    # Prepend user ID to trip number to ensure uniqueness across users
    df['Trip'] = (df['User'].astype(str) + "_" + df['Trip'].astype(str)).astype(str)
    segmented_df = segment_trips(df)
    All_Df[user] = segmented_df

# Print trips, and th corresponding dates and modes for a specific user
# Set pandas to display all rows
pd.set_option('display.max_rows', None)

user_to_print = '53'

if user_to_print in All_Df:
     user_data = All_Df[user_to_print]
     print(f"Trip and Mode data for User {user_to_print}:")
     print(user_data[['Trip', 'Mode', 'Date']])
else:
    print(f"User {user_to_print} not found in the dictionary.")

# Look for multiple modes in a single trip

results = []


for user, df in All_Df.items():
    grouped = df.groupby('Trip')

    for trip, group in grouped:
        if len(group['Mode'].unique()) > 1:
            results.append((user, trip, group['Mode'].unique().tolist()))

for user, trip, modes in results:
    print(f"User {user} has trip {trip} with multiple modes: {modes}")

All_Df['56']

with open("003_Labeled_GeoLife.pickle", 'wb') as f:
    pickle.dump(All_Df, f)

All_Df['86']